URI Handling
============

URIs are a convenient method for endpoints to convey connectivity
information in any out-of-band medium. This defines a process for
handling any URI to automatically detect associated keys and paths, as
well as standard practices for embedding that information in any
generated URIs.

Once a URI is successfully resolved and a link is established to an
endpoint the key and path information should be stored and used in place
of the URI, a successful resolution only needs to be performed once.

Generation
----------

New URIs that are generated by applications for the sole purpose of
establishing a new link take the minimal form of:
``link://host:port/?csid=base32``

-  ``link://`` - defaults to ``link`` but may be any app-specific name
   for registering custom URL handlers
-  ``host:port`` - the ``host`` is often an IP address, and the port
   defaults to ``42424`` if not included
-  ``csid=base32`` - (optional) a key/value pair for each of the
   sender's public keys

A generated URI will often include additional pathname or query string
values as needed by the application.

Examples:

::

    chat://127.0.0.1:55772/?cs1a=aof7baqdudm3mmjgexy5yqxj3m23pcsupy

Router / Peer
~~~~~~~~~~~~~

A common architecture includes a designated router that facilitates the
connection process with peers. The router can generate an authorative
base URI for peers to re-use and advertises it to them in a
`path <channels/path.md.rst>`__ request. This allows a peer to be
reachable via a URI but still remain private and not share any of its
identity information (hashname, keys, or paths).

The router may include its own keys in the query string but may not
attach a ``#fragment`` so that a peer can use the fragment part to
include additional data before distributing the URI. The router must
always include a value in the base URI to validate the request and
internally map it to the peer it was generated for, it should never
embed or expose the hashname or other specific details about the peer in
the base URI.

The peer endpoint must generate a fragment value that it can use to
validate incoming requests and the recipient can use to verify the
peer's hashname. This fragment is always a base32 encoded byte string of
at least 16 bytes in length when decoded. The last 8 bytes are always
the `SipHash <http://en.wikipedia.org/wiki/SipHash>`__ digest of all of
the previous bytes, using the first 16 bytes of the peer's hashname as
the key input to the digest (identical to the `chat
channel <channels/chat.md.rst>`__). The 8+ variable bytes in the
fragment must be generated by the peer such that they are unique for
every URI it shares.

When the URI is resolved and the peer must always respond with a URI
handshake and the connecting party must verify that the hashname is the
correct key to generate the digest in the fragment. This ensures that
only that peer can correctly link from a specific URI and that the
router cannot redirect to another party.

Example URI that uses a router as the base and includes the peer
fragment:

::

    link://127.0.0.1/?sid=1zm3hv7g&cs1a=aof7baqdudm3mmjgexy5yqxj3m23pcsupy#jpnzr4n33kwqbgpw3mduf7takvczpx2gafzjc2ppfc4yrxkltzsa

When a URI is processed that contains a fragment it generates a new
`peer <channels/peer.md.rst>`__ request to the router that includes the
``"uri":"..."`` (without the fragment) for the router to validate and
resolve to the right peer. The peer request must still also include a
full URI handshake to be forwarded directly to the peer for its own
validation.

Processing:
-----------

1. detect included keys in the query string and derive hashname

-  [optional] fallback to discover keys via WebFinger
-  fallback to resolve the canonical hostname to discover keys via DNS
   SRV
-  fallback to discover keys via HTTPS well-known

2. generate paths for all supported transports with any resolved IP and
   port
3. create a link with the keys and path(s) including a URI handshake
4. if there's a fragment hashname, issue a ``peer`` request over the
   link to it including a URI handshake

-  process any response URI handshake with a validating fragment as the
   final resolution

Embedded Keys
-------------

The Cipher Set keys for an endpoint may be included in the query string
of any existing URI.

Each ``CSID`` is included as an individual key/value pair where the key
is the format ``cs??`` (``cs1a``, ``cs2a``, etc) and the value is always
the base32 encoded key bytes.

Embedded Paths
--------------

The current paths may also be included in the query string of any
existing URI. Each available path has its JSON object base32 encoded as
the value and is included with a common ``paths`` key, multiple paths
have the same key.

When the paths are able to be generated from the hostname in the URI it
is not necessary to include them in the query string.

Example paths:

.. code:: json

    [
        {
            "url": "http://192.168.0.36:42424",
            "type": "http"
        },
        {
            "ip": "192.168.0.36",
            "port": 42424,
            "type": "udp4"
        },
        {
            "ip": "fe80::bae8:56ff:fe43:3de4",
            "port": 42424,
            "type": "tcp6"
        }
    ]
    URL: proto://host/path?key=value&paths=pmrhk4tmei5ce2duorydulzpge4telrrgy4c4mbogm3dunbsgqzdiirmej2hs4dfei5ce2duoryce7i&paths=pmrgs4bchirdcojsfyytmobogaxdgnrcfqrha33soqrdunbsgqzdilbcor4xazjchirhkzdqgqrh2&paths=pmrgs4bchirgmzjyga5duytbmu4dunjwmztduztfgqztum3emu2celbcobxxe5bchi2denbsgqwce5dzobsseorcorrxanrcpu

Generated Paths
---------------

The ``canonical`` hostname (or IP and port) of a URI or the resolved SRV
``port`` and ``IP`` should be treated as a potential ``path`` for all
available transports for an endpoint. Handshakes should be sent to the
given address in every transport supported that can use an IP and port,
including UDP, TCP, TLS, and HTTP(S).

Link Discovery
--------------

When an endpoint's keys cannot be included directly in the URI they may
be discovered via automated techniques from other parts of the URI.

DNS Links
~~~~~~~~~

SRV records always resolve to a hashname-prefixed host, with TXT records
returning all of the keys.

-  ``_link._udp.example.com. 86400 IN SRV 0 5 42424 uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g.example.com.``
-  ``uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN A 1.2.3.4``
-  ``uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "1a=base32"``
-  ``uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "2a=base32"``
-  ``uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "2a2=base32"``
-  ``uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "3a=base32"``

If a key's base32 encoding is larger than 250 characters (TXT limit), it
is broken into multiple TXT records with the ``CSID`` being numerically
increased so that it can be consistently reassembled.

No other DNS record type is supported, only SRV records resulting in one
or more A and TXT records.

WebFinger Links
~~~~~~~~~~~~~~~

Use `WebFinger <https://tools.ietf.org/html/rfc7033>`__ against the
canonical hostname, passing the given URI in as the ``resource`` and a
``rel`` value of ``http://telehash.org/link``. If successful, it will
result in a valid ``href`` that must return the standard
`JSON <json.md.rst>`__ link description format.

::

    GET https://example.com/.well-known/webfinger?resource=http://example.com/~user1&ref=http://telehash.org/link
    {
      "subject": "http://example.com/~user1",
      "links" : [
        {
          "rel" : "http://telehash.org/link",
          "href" : "https://www.example.com/~user1/link.json"
        }
      ]
    }

    GET https://example.com/~user1/link.json
    {
      "keys":{...},
      "paths":[...]
    }

HTTPS ``well-known`` Links
~~~~~~~~~~~~~~~~~~~~~~~~~~

Return the standard `JSON <json.md.rst>`__ link description format under
the root ``/.well-known/`` path:

\`\`\` GET https://example.com/.well-known/link.json { "keys":{...},
"paths":[...] }

URI Handshake
-------------

When a URI is the source of a new link, a ``"type":"uri"``
`handshake <e3x/handshake.md.rst#uri>`__ should be sent including the
original URI.

Example:

.. code:: json

    {
      "type":"uri",
      "uri":"https://example.com/link?ref=42#u8kbrrmk9apjbvgvn2wjechqr3vf9c1"
    }

